Coursera course: Introduction to Embedded Systems Software and Development Environments
University of Colorado Boulder

About this Course
Welcome to the Introduction to Embedded Systems Software and Development Environments. This course is focused on giving you real world coding experience and hands on project work with ARM based Microcontrollers. You will learn how to implement software configuration management and develop embedded software applications. Course assignments include creating a build system using the GNU Toolchain GCC, using Git version control, and developing software in Linux on a Virtual Machine. The course concludes with a project where you will create your own build system and firmware that can manipulate memory.

The second course in this 2 course series , Embedded Software and Hardware Architecture,  will use hardware tools to program and debug microcontrollers with bare-metal firmware. Using a Texas Instruments MSP432 Development Kit, you will configure a variety of peripherals, write numerous programs, and see your work execute on your own embedded platform!

Module 1
Module 1 will introduce the learner to the components of your embedded system software development process. This module will be a quick overview for many topics with detailed analysis to follow in later modules and courses. We start with defining the hardware and software building blocks of Embedded Systems which will include a C-programming refresher. Next you will learn about the important tools a developer will need to use to help design, build and manage their designs. This includes development environments, version control and the hardware kits to install on. Learners will install and use a Virtual machine to complete Week 1 Application Assignment.

Learning Objectives
- Define the components of an embedded system
- Classify the parts of an embedded systems developer’s Source Configuration Management (SCM)
- Apply Git Version Control to software projects
- Write a simple programming assignment that prints statistics to the command line using a variety of c-programming operators and features.
- Perform Compilation with GCC and execute output files from the command line.
- Use git Version control to create a repository to version control code.

Assignment
In this programming assignment you will create a simple application that performs statistical analytics on a dataset. This assignment will help you get re-oriented with c-programming syntax and host machine compilation. We begin by setting up a version control repository on your local machine. You will then develop and test your code there. When complete, you will upload a zip of your repository to Coursera. Please read through all instructions before starting.

After completing this assignment, you will be able to:
- Write a simple programming assignment that prints statistics to the command line using a variety of c-programming operators and features.
- Perform Compilation with GCC and execute output files from the command line.
- Use git Version control to create a repository to version control code.

Module 2
Module 2 will introduce the learner to the software development build system. Most software engineers are very knowledgeable about their build system as we need them to translate our high-level software languages to our architecture specific implementations. There are some important platform and architecture concepts that are introduced in the build system to help enforce good software design techniques. Learners will create their own build systems and utilize build tools to analyze their embedded software implementations.

Learning Objectives
- Implement a build system using GNU’s Make and GCC compiler toolsets
- Examine the pre-processor's role in compilation
- Integrate new libraries to a build system
- Write a makefile that can natively and cross compile an application
- Generate preprocessor, assembly, object, dependency, executable, and map output files

Assignment
In this programming assignment you will create a build system using the GNU tools, GCC and GNU Make. This assignment will require you to compile multiple files, link them together and create a final output executable. Some files will be provided for you, but you will need to support two platforms; the host environment and the target embedded system MSP432. The host system will allow you to simulate software on a host platform. The target system will be used in upcoming assignments as we begin to create our microcontroller applications.

After completing this assignment, you will be able to:
- Use GCC and GNU Make to create a command line build system
- Write a makefile that can natively and cross compile an application
- Generate preprocessor, assembly, object, dependency, executable, and map output files

Module 3
Module 3 will begin to introduce important embedded concepts like the memory systems in their design. Learners will understand how the software to hardware mapping occurs for their designs including differentiating between your program code and your program data. Memory systems have many platform and architecture dependencies, and you will begin to learn about some of the fundamental concepts a software engineer needs to know to utilize all parts of an embedded system’s memory.

Learning Objectives
- Analyze the components of a program’s memory space for both code and data regions
- Write C-programs to define data in different memory regions
- Interpret application’s map and linker files
- Use GCC Binary Utilities to investigate the memory usage of an executable
- Investigate the map file for the memory usage of an executable
- Determine where compiled code and data symbols are allocated, the lifetime of these symbols and the access restrictions

Assignment
In this programming assignment you will need to analyze some allocated memory. To do this, you will use a variety of the your knowledge gained in the module in addition to any of the GCC tools.

After completing this assignment, you will be able to:
- Use GCC Binary Utilities to investigate the memory usage of an executable
- Investigate the map file for the memory usage of an executable
- Determine where compiled code and data symbols are allocated, the lifetime of these symbols and the access restrictions
